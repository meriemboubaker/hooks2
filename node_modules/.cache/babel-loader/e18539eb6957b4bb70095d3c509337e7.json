{"ast":null,"code":"'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%'); // var $BigInt = GetIntrinsic('%BigInt%', true);\n// var $pow = GetIntrinsic('%Math.pow%');\n// var BinaryAnd = require('./BinaryAnd');\n// var BinaryOr = require('./BinaryOr');\n// var BinaryXor = require('./BinaryXor');\n\nvar Type = require('./Type'); // var modulo = require('./modulo');\n// var zero = $BigInt && $BigInt(0);\n// var negOne = $BigInt && $BigInt(-1);\n// var two = $BigInt && $BigInt(2);\n// https://262.ecma-international.org/11.0/#sec-bigintbitwiseop\n\n\nmodule.exports = function BigIntBitwiseOp(op, x, y) {\n  if (op !== '&' && op !== '|' && op !== '^') {\n    throw new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');\n  }\n\n  if (Type(x) !== 'BigInt' || Type(y) !== 'BigInt') {\n    throw new $TypeError('`x` and `y` must be BigInts');\n  }\n\n  if (op === '&') {\n    return x & y;\n  }\n\n  if (op === '|') {\n    return x | y;\n  }\n\n  return x ^ y;\n  /*\n  var result = zero;\n  var shift = 0;\n  while (x !== zero && x !== negOne && y !== zero && y !== negOne) {\n  \tvar xDigit = modulo(x, two);\n  \tvar yDigit = modulo(y, two);\n  \tif (op === '&') {\n  \t\tresult += $pow(2, shift) * BinaryAnd(xDigit, yDigit);\n  \t} else if (op === '|') {\n  \t\tresult += $pow(2, shift) * BinaryOr(xDigit, yDigit);\n  \t} else if (op === '^') {\n  \t\tresult += $pow(2, shift) * BinaryXor(xDigit, yDigit);\n  \t}\n  \tshift += 1;\n  \tx = (x - xDigit) / two;\n  \ty = (y - yDigit) / two;\n  }\n  var tmp;\n  if (op === '&') {\n  \ttmp = BinaryAnd(modulo(x, two), modulo(y, two));\n  } else if (op === '|') {\n  \ttmp = BinaryAnd(modulo(x, two), modulo(y, two));\n  } else {\n  \ttmp = BinaryXor(modulo(x, two), modulo(y, two));\n  }\n  if (tmp !== 0) {\n  \tresult -= $pow(2, shift);\n  }\n     return result;\n     */\n};","map":{"version":3,"sources":["C:/Users/DELL/Downloads/hook2-main/node_modules/es-abstract/2020/BigIntBitwiseOp.js"],"names":["GetIntrinsic","require","$TypeError","Type","module","exports","BigIntBitwiseOp","op","x","y"],"mappings":"AAAA;;AAEA,IAAIA,YAAY,GAAGC,OAAO,CAAC,eAAD,CAA1B;;AAEA,IAAIC,UAAU,GAAGF,YAAY,CAAC,aAAD,CAA7B,C,CACA;AACA;AAEA;AACA;AACA;;AACA,IAAIG,IAAI,GAAGF,OAAO,CAAC,QAAD,CAAlB,C,CACA;AAEA;AACA;AACA;AAEA;;;AAEAG,MAAM,CAACC,OAAP,GAAiB,SAASC,eAAT,CAAyBC,EAAzB,EAA6BC,CAA7B,EAAgCC,CAAhC,EAAmC;AACnD,MAAIF,EAAE,KAAK,GAAP,IAAcA,EAAE,KAAK,GAArB,IAA4BA,EAAE,KAAK,GAAvC,EAA4C;AAC3C,UAAM,IAAIL,UAAJ,CAAe,iDAAf,CAAN;AACA;;AACD,MAAIC,IAAI,CAACK,CAAD,CAAJ,KAAY,QAAZ,IAAwBL,IAAI,CAACM,CAAD,CAAJ,KAAY,QAAxC,EAAkD;AACjD,UAAM,IAAIP,UAAJ,CAAe,6BAAf,CAAN;AACA;;AAED,MAAIK,EAAE,KAAK,GAAX,EAAgB;AACf,WAAOC,CAAC,GAAGC,CAAX;AACA;;AACD,MAAIF,EAAE,KAAK,GAAX,EAAgB;AACf,WAAOC,CAAC,GAAGC,CAAX;AACA;;AACD,SAAOD,CAAC,GAAGC,CAAX;AACA;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACC,CA7CD","sourcesContent":["'use strict';\n\nvar GetIntrinsic = require('get-intrinsic');\n\nvar $TypeError = GetIntrinsic('%TypeError%');\n// var $BigInt = GetIntrinsic('%BigInt%', true);\n// var $pow = GetIntrinsic('%Math.pow%');\n\n// var BinaryAnd = require('./BinaryAnd');\n// var BinaryOr = require('./BinaryOr');\n// var BinaryXor = require('./BinaryXor');\nvar Type = require('./Type');\n// var modulo = require('./modulo');\n\n// var zero = $BigInt && $BigInt(0);\n// var negOne = $BigInt && $BigInt(-1);\n// var two = $BigInt && $BigInt(2);\n\n// https://262.ecma-international.org/11.0/#sec-bigintbitwiseop\n\nmodule.exports = function BigIntBitwiseOp(op, x, y) {\n\tif (op !== '&' && op !== '|' && op !== '^') {\n\t\tthrow new $TypeError('Assertion failed: `op` must be `&`, `|`, or `^`');\n\t}\n\tif (Type(x) !== 'BigInt' || Type(y) !== 'BigInt') {\n\t\tthrow new $TypeError('`x` and `y` must be BigInts');\n\t}\n\n\tif (op === '&') {\n\t\treturn x & y;\n\t}\n\tif (op === '|') {\n\t\treturn x | y;\n\t}\n\treturn x ^ y;\n\t/*\n\tvar result = zero;\n\tvar shift = 0;\n\twhile (x !== zero && x !== negOne && y !== zero && y !== negOne) {\n\t\tvar xDigit = modulo(x, two);\n\t\tvar yDigit = modulo(y, two);\n\t\tif (op === '&') {\n\t\t\tresult += $pow(2, shift) * BinaryAnd(xDigit, yDigit);\n\t\t} else if (op === '|') {\n\t\t\tresult += $pow(2, shift) * BinaryOr(xDigit, yDigit);\n\t\t} else if (op === '^') {\n\t\t\tresult += $pow(2, shift) * BinaryXor(xDigit, yDigit);\n\t\t}\n\t\tshift += 1;\n\t\tx = (x - xDigit) / two;\n\t\ty = (y - yDigit) / two;\n\t}\n\tvar tmp;\n\tif (op === '&') {\n\t\ttmp = BinaryAnd(modulo(x, two), modulo(y, two));\n\t} else if (op === '|') {\n\t\ttmp = BinaryAnd(modulo(x, two), modulo(y, two));\n\t} else {\n\t\ttmp = BinaryXor(modulo(x, two), modulo(y, two));\n\t}\n\tif (tmp !== 0) {\n\t\tresult -= $pow(2, shift);\n\t}\n    return result;\n    */\n};\n"]},"metadata":{},"sourceType":"script"}